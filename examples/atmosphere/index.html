<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atmosphere</title>
  <script src="../../dist/toygl.js"></script>
  <script src="./hdrpng.js"></script>
  <script src="../ThirdParty/tweakpane-3.0.7.js"></script>
  <style>html, body { margin: 0; }</style>
</head>
<body>
  <script type="module">
    import SkyAtmosphere from './SkyAtmosphere.js';

    const gl = ToyGL.createContext();
    document.body.appendChild(gl.canvas);

    const ndcQuadVAO = ToyGL.createVAO(gl, {
      attributes: {
        a_position: {
          location: 0,
          size: 2,
          data: [
            -1, -1,
            1, -1,
            -1,  1,
            1,  1,
          ]
        },
      },
      indices: [0, 1, 2, 1, 2, 3],
    });

    const skyAtmosphere = new SkyAtmosphere(gl);
    window.skyAtmosphere = skyAtmosphere;

    const canvas = gl.canvas;
    const { Cartesian2, Cartesian3, Cartesian4, Matrix4 } = ToyGL;

    const NormalizedQuadVert = await fetch('./NormalizedQuad.vert').then(r => r.text());

    const fovy = 40 / 180 * Math.PI;
    const aspect = canvas.clientWidth / canvas.clientHeight;
    const near = 0.1;
    const far = 1e3;
    const projectionMatrix = Matrix4.computePerspectiveFieldOfView(fovy, aspect, near, far, new Matrix4());

    const eyePos = new Cartesian3(0, 0, skyAtmosphere.groundRadiusMM + (1 * 1e-3));
    const eyeDir = new Cartesian3(0, 1, 0).normalize();
    const eyeUp = Cartesian3.normalize(eyePos, new Cartesian3());
    // const eyeUp = new Cartesian3(0, 0, 1);
    const eyeRight = Cartesian3.cross(eyeDir, eyeUp, new Cartesian3());
    // const eyeRight = new Cartesian3(0, 0, 1);
    // Cartesian3.cross(eyeRight, eyeDir, eyeUp);
    const viewMatrix = Matrix4.computeView(eyePos, eyeDir, eyeUp, eyeRight, new Matrix4());

    const viewProjectionMatrix = Matrix4.multiply(projectionMatrix, viewMatrix, new Matrix4());
    const invViewProjectionMatrix = Matrix4.inverse(viewProjectionMatrix, new Matrix4());

    const param = {
      eyeDir: eyeDir,
      longitude: {
        x: 0,
        y: 1,
      },
      height: (eyePos.z - skyAtmosphere.groundRadiusMM) * 1e3,
    };
    const pane = new Tweakpane.Pane();
    pane
      .addInput(param, 'longitude', {
        picker: 'inline',
        expanded: true,
        x: {
          min: -1,
          max: 1,
        },
        y: {
          min: -1,
          max: 1,
        },
      })
      .on('change', () => {
        Cartesian2.normalize(param.longitude, param.longitude);
        eyeDir.x = param.longitude.x;
        eyeDir.y = param.longitude.y;
        eyeDir.normalize();
      });
    pane
      .addInput(param, 'height', {
        min: 0.001,
        max: 200,
      })
      .on('change', () => {
        eyePos.z = skyAtmosphere.groundRadiusMM + param.height * 1e-3;
      });


    canvas.addEventListener('mousemove', e => {
      const x = (e.x/canvas.clientWidth) * 2 - 1;
      const y = (1 - e.y/canvas.clientHeight) * 2 - 1;
      const ndc = new Cartesian4(x, y, 0.1, 1);
      const worldPos = Matrix4.multiplyByVector(invViewProjectionMatrix, ndc, new Cartesian4());
      Cartesian4.divideByScalar(worldPos, worldPos.w, worldPos);
      const worldDir = Cartesian3
        .subtract(worldPos, eyePos, new Cartesian3())
        .normalize();

      Cartesian3.clone(worldDir, skyAtmosphere.atmosphereLightDirection0);
      // dir.z = -dir.z;
      Cartesian3.negate(worldDir, skyAtmosphere.atmosphereLightDirection1);
      // Cartesian3.clone(skyAtmosphere.atmosphereLightDirection0, skyAtmosphere.atmosphereLightDirection1);
      // skyAtmosphere.atmosphereLightDirection1.z = -skyAtmosphere.atmosphereLightDirection1.z;
      // skyAtmosphere.atmosphereLightDirection1.x = skyAtmosphere.atmosphereLightDirection1.x + 0.1;
      // skyAtmosphere.atmosphereLightDirection1.normalize();

    });


    function render(ms) {
      requestAnimationFrame(render);

      // Update Scene
      Cartesian3.cross(eyeDir, eyeUp, eyeRight);
      Matrix4.computeView(eyePos, eyeDir, eyeUp, eyeRight, viewMatrix);
      Matrix4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
      Matrix4.inverse(viewProjectionMatrix, invViewProjectionMatrix);

      // Update SkyAtmosphere
      eyePos.clone(skyAtmosphere._viewPosition);
      eyeDir.clone(skyAtmosphere._viewDirection);
      // eyeUp.clone(skyAtmosphere._viewUp);
      eyeRight.clone(skyAtmosphere._viewRight);
      viewMatrix.clone(skyAtmosphere._viewMatrix);
      projectionMatrix.clone(skyAtmosphere._projectionMatrix);
      invViewProjectionMatrix.clone(skyAtmosphere._invViewProjectionMatrix);

      // Renderer
      skyAtmosphere.renderSkyAtmosphereLookUpTables();
      skyAtmosphere.renderSkyAtmosphere({
        framebuffer: null,
        viewport: new Cartesian4(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight),
      });
      // return;

      // blitTextureToCanvas(skyAtmosphere._transmittanceLutTexture);
      // blitTextureToCanvas(skyAtmosphere._multiScatteredLuminanceLutTexture);
      // blitTextureToCanvas(skyAtmosphere._skyViewLutTexture);
      return;
    }

    requestAnimationFrame(render);

    function blitTextureToCanvas(texture) {
      if (!texture) return;

      ToyGL.setState(gl, {
        viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight],
        cull: {
          enable: false,
        },
      });
      ToyGL.draw(gl, {
        vs: NormalizedQuadVert,
        fs: `
          precision highp float;
          uniform sampler2D uTexture;
          varying vec2 uv;
          void main() {
            gl_FragColor = texture2D(uTexture, vec2(uv.x, 1.-uv.y));
            // gl_FragColor = vec4(uv, 0, 1);
          }
        `,
        attributeLocations: {
          a_position: 0,
        },
        uniforms: {
          uTexture: texture,
        },
        vao: ndcQuadVAO,
        count: 6,
        fb: null,
      });
    }
  </script>
</body>
</html>